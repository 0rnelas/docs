Аутентификация
##############

.. php:class:: AuthComponent(ComponentCollection $collection, array $config = [])

Идентификация, аутентификация и авторизация пользователей является обычной частью
почти каждого веб-приложения. В CakePHP AuthComponent предоставляет
подключаемый способ выполнения этих задач. AuthComponent позволяет комбинировать
объекты аутентификации и объекты авторизации для создания гибких
способов идентификации и проверки авторизации пользователя.

.. _authentication-objects:

Рекомендуется к прочтению
=========================

Настройка аутентификации требует нескольких шагов, включая определение
таблицы пользователей, создание модели, контроллера, видов и т. д.

Это все описывается по шагам в
:doc:`Руководстве по созданию CMS </tutorials-and-examples/cms/authentication>`.

Если вы ищете готовые решения по аутентификации и/или авторизации для
CakePHP, взгляните на раздел 
`Аутентификация и Авторизация <https://github.com/FriendsOfCake/awesome-cakephp/blob/master/README.md#authentication-and-authorization>`_ списка Awesome CakePHP.

Аутентификация
==============

Аутентификация - это процесс идентификации пользователей посредством
учетных данных и обеспечение того, чтобы пользователи были теми, за кого они
себя выдают. Как правило, это делается с помощью имени пользователя и пароля,
которые проверяются по списку известных  пользователей. В CakePHP есть
несколько встроенных способов аутентификации пользователей, имеющихся у вашего 
приложения.

* ``FormAuthenticate`` позволяет аутентификацию пользователей на основании 
  POST-данных, отправляемых с помощью форм. Как правило, это форма входа с
  с возможностью ввода учетных данных пользователем.
* ``BasicAuthenticate`` предоставляет возможности Базовой HTTP-аутентификации.
* ``DigestAuthenticate`` предоставляет возможности Дайджест-аутентификации.

По умолчанию ``AuthComponent`` использует ``FormAuthenticate``.

Выбор типа аутентификации
-------------------------

Как правило, вы захотите предложить аутентификацию на основе форм. Это самый
простой способ для пользователей веб-браузеров. Если вы создаете API или веб-сервис,
вы можете рассмотреть базовую аутентификацию или дайджест-аутентификацию. Основные
различия между дайджест- и базовой аутентификацией в основном связаны с тем, как
обрабатываются пароли. При базовой аутентификации имя пользователя и пароль
передаются в виде обычного текста на сервер. Это делает базовую аутентификацию 
непригодной для приложений без SSL, так как вы будете подвергать пароли уязвимости.
Дайджест-аутентификация передает в  хэшированном виде имя пользователя, пароль и
некоторые другие детали. Это делает дайджест-аутентификацию  более подходящей для
приложений без SSL-шифрования.

Вы также можете использовать такие системы аутентификации, как например OpenID,
но они уже не входят в состав ядра CakePHP.

Настройка обработчиков аутентификации
-------------------------------------

Вы настраиваете обработчики аутентификации, используя конфигурацию
``authenticate``. Вы можете настроить один или несколько обработчиков
для аутентификации. Использование нескольких обработчиков позволяет
вам поддерживать разные способы входа пользователей. Когда пользователи
авторизуются, обработчики аутентификации проверяются в том порядке,
в котором они были объявлены. Как только какой-либо обработчик сможет
идентифицировать пользователя, все оставшиеся обработчики уже не будут
использованы. И наоборот, вы можете прервать проверку подлинности,
выбросив исключение. Вам будет нужно перехватывать любые выбрасываемые
исключения и обрабатывать их должным образом.

Вы можете настроить обработчики аутентификации в методе 
``beforeFilter()`` либо ``initialize()``. Вы можете передавать
информацию о конфигурации в каждый объект аутентификации, используя
массив::

    // Простая настройка
    $this->Auth->config('authenticate', ['Form']);

    // Передача параметров
    $this->Auth->config('authenticate', [
        'Basic' => ['userModel' => 'Members'],
        'Form' => ['userModel' => 'Members']
    ]);

Во втором примере вы возможно обратили внимание, что ключ ``userModel``
был объявлен дважды. Чтобы ваш код соответствовал принципам DRY (не
повторяйся), вы можете использовать ключ ``all``. Этот специальный ключ
позволяет вам устанавливать параметры, которые вы передаете к каждому
прикрепленному объекту. Ключ ``all`` также доступен в качестве
статического свойства ``AuthComponent::ALL``::

    // Передача параметров с помощию 'all'
    $this->Auth->config('authenticate', [
        AuthComponent::ALL => ['userModel' => 'Members'],
        'Basic',
        'Form'
    ]);

В приведенном выше примере и ``Form`` и ``Basic`` будут получать настройки,
объявленные в ключе 'all'. Любые настройки, переданные конкретному объекту
аутентификации будут переопределять соответствующие ключи внутри ключа 'all'.
Объекты аутентификации ядра поддерживают следующие ключи конфигурации.

- ``fields`` Поля, используемые для аутентификации пользователя. Вы можете
  использовать ключи ``username`` и ``password``, чтобы указать поля для
  имени пользователя и пароля соответственно.
- ``userModel`` Имя модели для таблицы пользователей; По умолчанию - Users.
- ``finder`` Метод-файндер для получения записи из таблицы пользователей.
  По умолчанию устновлен в 'all'.
- ``passwordHasher`` Класс хешера паролей; По умолчанию ``Default``.
- Опции ``scope`` и ``contain`` являются устаревшими в версии 3.1. Используйте
  вместо них пользовательские файндеры для изменения запроса на выборку записи
  пользователя.
- Опция ``userFields`` является устаревшей в версии 3.1. Используйте метод 
  ``select()`` в вашем пользовательском файндере.
  
Чтобы настроить дополнительные поля для записи пользвателя в методе
``initialize()``::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'authenticate' => [
                'Form' => [
                    'fields' => ['username' => 'email', 'password' => 'passwd']
                ]
            ]
        ]);
    }

Не помещайте другие ключи конфигурации ``Auth``, такие как ``authError``, ``loginAction``,
и т.д. внутрь элементов ``authenticate`` или ``Form``. Они должны находиться на одном
с ними уровне. Приведенная выше настройка конфигурации компонента ``Auth`` с использованием
остальных параметров должна выглядеть так::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'loginAction' => [
                'controller' => 'Users',
                'action' => 'login',
                'plugin' => 'Users'
            ],
            'authError' => 'Вы правда думали, что вам можно видеть это?',
            'authenticate' => [
                'Form' => [
                    'fields' => ['username' => 'email']
                ]
            ],
            'storage' => 'Session'
        ]);
    }
    
В дополнение к стандартной конфигурации, Базовая аутентификация (Basic)
также поддерживает следующие ключи:

- ``realm`` Область, для которой предназначена аутентификация.
  По умолчанию ``env('SERVER_NAME')``.

В дополнение к стандартной конфигурации, Дайджест-аутентификация
также поддерживает следующие ключи:

- ``realm`` Область, для которой предназначена аутентификация.
  По умолчанию servername (имя сервера).
- ``nonce`` Значение nonce для аутентификации. По умолчанию ``uniqid()``.
- ``qop`` По умолчанию auth; другие значения пока не поддерживаются.
- ``opaque`` Строка, которая должна быть возвращена в неизменном виде
  клиентами. По умолчанию ``md5($config['realm'])``.

.. note::
    Чтобы найти запись пользователя, запрос к базе  данных происходит только
    с использованием имени пользователя. Проверка пароля производится в PHP.
    Это связано с тем, что алгоритмы хеширования, такие как bcrypt (алгоритм
    по умолчанию) генерируют новый хеш каждый раз, даже для неизменной строки,
    и в данном случае обычное сравнение строк в SQL становится неприменимым
    для проверки пароля.
    
Кастомизация поискового запроса
-------------------------------

Вы можете кастомизировать запрос на выборку записи пользователя с помощью
опции ``finder`` в группе параметров ``authenticate``::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'authenticate' => [
                'Form' => [
                    'finder' => 'auth'
                ]
            ],
        ]);
    }

Это потребует наличия поискового метода ``findAuth()`` в вашем классе модели
``UsersTable``. В приведенном ниже примере запрос скорректирован для выборки
значений только из необходимых полей и добавлено условие выборки значений.
Вы должны убедиться, что происходит выборка значений из необходимых полей,
таких как ``username`` и ``password``::

    public function findAuth(\Cake\ORM\Query $query, array $options)
    {
        $query
            ->select(['id', 'username', 'password'])
            ->where(['Users.active' => 1]);

        return $query;
    }

.. note::
    Опция ``finder`` доступна только с версии 3.1. В более ранних версиях вы
    можете использовать опции ``scope`` и ``contain`` для изменения запроса.
    
Идентификация и вход пользователей
----------------------------------

.. php:method:: identify()

Вам необходимо вручную вызывать ``$this->Auth->identify()``, чтобы
идентифицировать пользователя, используя учетные данные предоставленные
в запросе. После этого вы должны использовать метод ``$this->Auth->setUser()``,
чтобы пользователь вошел в приложение, то есть данные о нем сохранились в
сессии.

При аутентификации пользователей прикрепленные объекты аутентификации
проверяются в том порядке, в котором они прикреплены. Как только один из
объектов сможет идентифицировать пользователя, другие объекты уже не проверяются.
Пример функции для работы с формой входа может выглядеть так::

    public function login()
    {
        if ($this->request->is('post')) {
            $user = $this->Auth->identify();
            if ($user) {
                $this->Auth->setUser($user);
                return $this->redirect($this->Auth->redirectUrl());
            } else {
                $this->Flash->error(__('Username or password is incorrect'));
            }
        }
    }

Приведенный выше код сначала попробует идентифицировать пользователя, используя
POST-данные. В случае успеха данные о пользователе будут сохранены в сессии, благодаря
чему будут доступны между отправкой запросов, и после этого будет осуществляться
перенаправление на последнюю посещенную страницу, либо на URL, указанный в параметре
конфигурации ``loginRedirect``. В случае, если попытка входа окажется неудачной -
выведется флеш-сообщение об ошибке.

.. warning::

    Метод ``$this->Auth->setUser($data)`` авторизует пользователя, независимо от того,
    какие данные были ему переданы. Он не будет проверять пользовательские данные на
    соответствие классу аутентификации.
    
Перенаправление пользователей после входа
-----------------------------------------

.. php:method:: redirectUrl

После входа пользователя в систему вы, как правило, захотите перенаправить их
обратно туда, откуда они пришли. Передайте URL-адрес для установки целевой
страницы, на которую пользователь должен быть перенаправлен после входа в
систему.

Если параметр не будет передан, возвращаемый URL будет подчиняться следующим
правилам:

- Возвращается нормализованный URL из значения ``redirect`` строки запроса если
  он существует и находится в тод же домене, что и текущее приложение. До версии
  3.4.0  использовалось значение сессионной переменной ``Auth.redirect``.
- Если в строке запроса/сессии нужное значение отсутствует, но присвоено
  какое-либо значение параметру конфигурации ``loginRedirect``, то будет
  возвращено это значение.
- Если же и в параметре ``loginRedirect`` не окажется нужного значения, будет
  возвращен ``/``.
  
Создание системы аутентификации без сохранения состояния
--------------------------------------------------------

Базовая и Дайджест-аутентификация - это системы аутентификации не сохраняющие
состояние, и не требующие исходных POST-данных или формы. Если вы используете
только эти два способа аутентификации, вашему котроллеру необязательно наличие
экшена входа в систему (login). Cистема аутентификации без сохранения состояния
перепроверяет данные пользователя при каждом запросе. это создает небольшое
количество дополнительных накладных расходов, но позволяет клиентам
осуществлять вход без использования куки и делает AuthComponent более гибким
при создании API.

Для аутентификаторов без сохранения состояния параметр конфигурации ``storage``
следует установить в ``Memory``, чтобы ``AuthComponent`` не использовал сеccию
для хранения  записи пользователя. Вы также можете настроить параметр конфигурации
``unauthorizedRedirect`` в ``false``, чтобы ``AuthComponent`` выбрасывал
``ForbiddenException`` вместо поведения по умолчанию перенаправления на ссылающуюся
страницу.

Объекты аутентификации могут реализовывать метод ``getUser()``, который может
использоваться для поддержки систем входа пользователя, независящих от файлов
cookie. Типичный метод ``getUser()`` рассматривает запрос/среду и использует эту
информацию для подтверждения личности пользователя. Например, Базовая HTTP-аутентификация
использует ``$_SERVER['PHP_AUTH_USER']`` и ``$_SERVER['PHP_AUTH_PW']`` для полей
имени пользователя и пароля.

.. note::

    Если аутентификация не работает как ожидается, проверьте, выполняются ли
    вообще запросы (смотрите ``BaseAuthenticate::_query($username)``).
    Если запросы не выполняются, проверьте заполняются ли веб-сервером
    ключи ``$_SERVER['PHP_AUTH_USER']`` и ``$_SERVER['PHP_AUTH_PW']``.
    Если вы используете Apache с FastCGI-PHP, вам возможно потребуется
    добавить следующую строку в ваш корневой файл **.htaccess**::

        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]

При каждом запросе данные значения, ``PHP_AUTH_USER`` и ``PHP_AUTH_PW``, используются
повторной идентификации пользователя, чтобы убедиться в их подлинности. Как и в
случае с методом объекта аутентификации ``authenticate()``, метод ``getUser()``
должен возвращать массив с информацией о пользователе, либо ``false`` в случае
неудачи.::

    public function getUser(ServerRequest $request)
    {
        $username = env('PHP_AUTH_USER');
        $pass = env('PHP_AUTH_PW');

        if (empty($username) || empty($pass)) {
            return false;
        }
        return $this->_findUser($username, $pass);
    }

Пример выше показывает, как вы можете реализовать метод ``getUser()``
для Базовой HTTP-аутентификации. Метод ``_findUser()`` является частью
``BaseAuthenticate``, и идентифицирует пользователя на основе имени
пользователя и пароля.

.. _basic-authentication:

Использование базовой аутентификации
------------------------------------

Базовая аутентификация позволяет создать аутентификацию без сохранения состояния,
которая может использоваться в приложениях интрасети или для простых сценариев API.
Данные пользователя при базовой аутентификации будут перепроверяться при каждом
запросе.

.. warning::
    Базовая аутентификация передает пользовательские данные в виде открытого
    текста. Вы должны использовать протокол HTTPS при использовании Базовой
    аутентификации.

Чтобы использовать базовую аутентификацию, вам понадобится настроить
``AuthComponent``::

    $this->loadComponent('Auth', [
        'authenticate' => [
            'Basic' => [
                'fields' => ['username' => 'username', 'password' => 'api_key'],
                'userModel' => 'Users'
            ],
        ],
        'storage' => 'Memory',
        'unauthorizedRedirect' => false
    ]);

Здесь мы используем имя пользователя + ключ API в качестве наших полей, а
также используем модель Users.

Создание ключей API для Базовой аутентификации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Так как базовый протокол HTTP передает пользовательские данные в виде открытого
текста, было бы неразумно, если бы пользователи передавали свои пароли. Вместо
этого обычно используется непрозрачный ключ API. Вы можете сгенерировать эти
API-токены произвольно, используя библиотеки входящие в состав CakePHP::

    namespace App\Model\Table;

    use Cake\Auth\DefaultPasswordHasher;
    use Cake\Utility\Text;
    use Cake\Event\Event;
    use Cake\ORM\Table;

    class UsersTable extends Table
    {
        public function beforeSave(Event $event)
        {
            $entity = $event->getData('entity');

            if ($entity->isNew()) {
                $hasher = new DefaultPasswordHasher();

                // Генерируем 'токен' API
                $entity->api_key_plain = sha1(Text::uuid());

                // Хешируем токен с помощью Bcrypt, чтобы BasicAuthenticate
                // мог его проверить при входе.
                $entity->api_key = $hasher->hash($entity->api_key_plain);
            }
            return true;
        }
    }

Приведенный выше код генерирует случайный хеш для каждого пользователя по мере
их сохранения. В приведенном выше коде предполагается, что у вас есть два поля
``api_key`` - для хранения хэшированного API-ключа и ``api_key_plain`` - для
открытой текстовой версии ключа API, чтобы мы могли позже отобразить его
пользователю. Использование ключа вместо пароля означает, что даже через
простой протокол HTTP пользователи могут использовать непрозрачный токен вместо
исходного пароля. Также разумно включить логику, позволяющую восстанавливать
ключи API по запросу пользователя.

Использование Дайджест-аутентификации
-------------------------------------

Дайджест-аутентификация предлагает улучшенную модель безопасности по сравнению с
базовой аутентификацией, так как пользовательские данные никогда не передаются
в заголовке запроса. Вместо этого перается хеш.

Чтобы использовать дайджест-аутентификацию, вам понадобится настроить
``AuthComponent``::

    $this->loadComponent('Auth', [
        'authenticate' => [
            'Digest' => [
                'fields' => ['username' => 'username', 'password' => 'digest_hash'],
                'userModel' => 'Users'
            ],
        ],
        'storage' => 'Memory',
        'unauthorizedRedirect' => false
    ]);

Здесь мы используем имя пользователя + digest_hash в качестве наших полей и используем
модель Users.

Хеширование паролей для дайджест-аутентификации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Поскольку для Дайджест-аутентификации требуется пароль, хэшированный
в формате, определенном RFC, для правильного хэширования пароля
для использования с Дайджест-аутентификацией вам следует использовать
специальную функцию хэширования пароля из ``DigestAuthenticate``. Если
вы собираетесь комбинировать дайджест-аутентификацию с любыми другими
стратегиями аутентификации, рекомендуется также сохранить
дайджест-пароль в отдельном поле,отличном от обычного хеша пароля::

    namespace App\Model\Table;

    use Cake\Auth\DigestAuthenticate;
    use Cake\Event\Event;
    use Cake\ORM\Table;

    class UsersTable extends Table
    {
        public function beforeSave(Event $event)
        {
            $entity = $event->getData('entity');

            // Создание пароля для дайджест-аутентификации.
            $entity->digest_hash = DigestAuthenticate::password(
                $entity->username,
                $entity->plain_password,
                env('SERVER_NAME')
            );
            return true;
        }
    }

Пароли для дайджест-аутентификации нуждаются в несколько большем количестве
информации, чем другие хеши паролей для дайджест-аутентификации, основанные
на RFC.

.. note::

    Третий параметр метода DigestAuthenticate::password() должен совпадать
    со значением параметра конфигурации 'realm', объявленным, когда
    DigestAuthentication настраивалось в AuthComponent::$authenticate.
    По умолчанию его значение - это ``env('SCRIPT_NAME')``. Возможно вам
    захочется изменить это значение на какую-нибудь статичную строку, если
    вы например хотите иметь согласованные хеши в различных окружениях.
    
Создание кастомных объектов аутентификации
------------------------------------------

Поскольку объекты аутентификации являются подключаемыми, вы можете
создавать собственные объекты аутентификации в своем приложении или плагинах.
Например, если вы хотите создать объект аутентификации OpenID.
В **src/Auth/OpenidAuthenticate.php** вы можете указать следующее::

    namespace App\Auth;

    use Cake\Auth\BaseAuthenticate;
    use Cake\Http\ServerRequest;
    use Cake\Http\Response;

    class OpenidAuthenticate extends BaseAuthenticate
    {
        public function authenticate(ServerRequest $request, Response $response)
        {
            // Делаем здесь необходимые действия для OpenID.
            // Возвращаем здесь массив с данным о пользователе,
            // либо возвращаем false в случае неудачи.
        }
    }

Объекты аутентификации должны возвращать ``false``, если идентификация
пользователя не удалась, либо массив с информацией о пользователе в
противном случае. Необязательно наследоваться от класса ``BaseAuthenticate``,
вы можете просто реализовать интерфейс ``Cake\Event\EventListenerInterface``.
Класс ``BaseAuthenticate`` предоставляет несколько полезных методов, которые
часто используются. Также вы можете реализовать метод ``getUser()``, если
ваш объект аутентификации поддерживает аутентификацию без сохранения
состояния или же без использования куки-файлов. Смотрите разделы по
базовой и дайджест-аутентификации ниже для более полной информации.

``AuthComponent`` запускает два события, ``Auth.afterIdentify`` и ``Auth.logout``,
после того, как пользователь был идентифицирован и перед его выходом из приложения
соответственно. Вы можете назначить коллбэк-функции для этих событий, задав их
в качестве значений в ассоциативном массиве внутри метода ``implementedEvents()``
вашего класса аутентификации::

    public function implementedEvents()
    {
        return [
            'Auth.afterIdentify' => 'afterIdentify',
            'Auth.logout' => 'logout'
        ];
    }
    
Использование кастомных объектов аутентификации
-----------------------------------------------

После того как вы создали свои собственные объекты аутентификации, вы
можете использовать ихвключая их в массив ``authenticate`` компонента
``AuthComponent``::

    $this->Auth->config('authenticate', [
        'Openid', // объект аутентификации приложения.
        'AuthBag.Openid', // объект аутентификации плагина.
    ]);

.. note::
    Обратите внимание, что при использовании простых обозначений
    при инициализации объекта аутентификации нет слова 'Authenticate'.
    Если вы все же используете пространства имен, вам нужно будет установить
    полное пространство имен класса, включая слово 'Authenticate'.
    
Обработка неаутентифицированных запросов
----------------------------------------

Когда пользователь, не прошедший проверку подлинности, пытается получить доступ
к защищенным страницам, прежде всего вызывается метод ``unauthenticated()``
последнего вызванного в цепочке аутентификатора. Объект аутентификации может
обрабатывать отправку ответа или перенаправление, возвращая объект ответа,
чтобы указать, что никаких дополнительных действий не требуется. В связи с этим,
порядок, в котором вы указываете провайдера аутентификации в параметре конфигурации
``authenticate``, имеет значение.

Если аутентификатор возвращает ``null``, то ``AuthComponent`` перенаправляет
пользователя на экшен входа(login). Если же это AJAX-запрос, и параметр
конфигурации ``ajaxLogin`` указывает, что элемент визуализируется иначе, то
будет возвращен код состояния HTTP 403.

Вывод флэш-сообщений компонента Auth
------------------------------------

Чтобы отображать сообщения об ошибках сессии, генерируемые ``Auth``, вам нужно
добавить следующий код в свой макет (``layout``). Добавьте следующие две
строки в файл **src/Template/Layout/default.ctp** в разделе ``body``::

    // Все, что необходимо для версий начиная с 3.4.0
    echo $this->Flash->render();

    // Для версий, предшествующих 3.4.0, потребуется следующее
    echo $this->Flash->render('auth');

Вы можете настроить сообщения об ошибках и параметры флэш-сообщений,
используемые ``AuthComponent``. Используя параметр конфигурации ``flash``, вы
можете настроить параметры, используемые AuthComponent для установки
флэш-сообщений. Доступные ключи:

- ``key`` - Используемый ключ, по умолчанию 'default'. В версиях ниже 3.4.0,
  по умолчанию использовалось значение 'auth'.
- ``element`` - Имя элемента использовать для визуализации, по
  умолчанию ``null``.
- ``params`` - Массив дополнительных используемых параметров, по
  умолчанию ``[]``.

В дополнение к настройкам флэш-сообщений, вы можете настраивать также и
другие сообщения об ошибках, используемые в ``AuthComponent``. В методе
``beforeFilter()``

In addition to the flash message settings you can customize other error
messages AuthComponent uses. In your controller's beforeFilter, or
component settings you can use ``authError`` to customize the error used
for when authorization fails::

    $this->Auth->config('authError', "Woopsie, you are not authorized to access this area.");

Sometimes, you want to display the authorization error only after
the user has already logged-in. You can suppress this message by setting
its value to boolean ``false``.

In your controller's beforeFilter() or component settings::

    if (!$this->Auth->user()) {
        $this->Auth->config('authError', false);
    }


.. meta::
    :title lang=ru: Аутентификация
    :keywords lang=ru: обработчики аутентификации,массив php,базовая аутентификация,веб-приложение,различные способы,учетные данные,исключения,cakephp,logging
