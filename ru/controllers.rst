Контроллеры
###########

.. php:namespace:: Cake\Controller

.. php:class:: Controller

Контроллеры - это то, что скрывается за буквой 'C' в понятии MVC. После того,
как срабатывает мршрутизация, и обнаруживается правильный котроллер, происходит
вызов нужного экшена. Ваш контроллер должен произвести верную интерпретацию данных
запроса, убедившись, что будет вызвана необходимая модель, и возвращен верный вид
и результат запроса. Контроллеры можно представить себе, как промежуточное звено
между Моделью и Видом. Старайтесь сохранять ваши контроллеры компактными,
помещая всю бизнес-логику внутри модели. Это сделает ваш код более гибким и
облегчит его повторное использование и тестирование.

Вцелом контроллер используется для построения логики в работе с конкретной моделью.
Например, если вы создаете сайт онлайн-пекарни, у вас вероятно будет контроллер
RecipesController, управляющий вашими рецептами, а также контроллер
IngredientsController управляющий вашими ингридиентами. Однако может быть и так,
что некоторые контроллеры могут работать более, чем с одной моделью. В CakePHP
контроллер именуется в соответствии с основной моделью, с которой он работает.

Все контроллеры вашего приложения наследуются от класса ``AppController``,
который в свою очередь наследуется от класса ядра :php:class:`Controller`.
Класс ``AppController`` может быть объявлен в файле
**src/Controller/AppController.php**, и он должен содержать методы, которые
будут общими для всех контроллеров вашего приложения.

Контроллеры предоставляют методы, обрабатывающие запросы. Эти методы называются
*экшены*. По умолчанию кажды открытый (public) метод в контроллере является экшеном,
и он доступен из URL. Экшен отвечает за обработку запроса и возвращает его результат.
Как правило ответ возвращается с использованием вида, но существуют и другие способы
создания ответов.

.. _app-controller:

Контроллер уровня приложения (AppController)
============================================

Как уже упоминалось во введении, класс ``AppController`` - это родительский класс
для всех контроллеров вашего приложения. Сам по себе класс ``AppController`` наследуется
от класса :php:class:`Cake\\Controller\\Controller`, входящего в состав CakePHP.
Класс ``AppController`` объявлен в файле **src/Controller/AppController.php**
следующим образом::

    namespace App\Controller;

    use Cake\Controller\Controller;

    class AppController extends Controller
    {
    }
    
Атрибуты и методы, прописанные в вашем классе ``AppController`` будут доступны во
всех ваших контроллерах, наследующихся от данного класса. Компоненты (о которых будет
рассказано далее) - это самый лучший вариант для кода, использующегося во многих (но
необязательно во всех) контроллерах.

Вы можете использовать ваш ``AppController`` для загрузки компонентов, которые будут
использоваться в каждом контроллере вашего приложения. CakePHP предоставляет метод
``initialize()``, который вызывается в конце коструктора Контроллера::

    namespace App\Controller;

    use Cake\Controller\Controller;

    class AppController extends Controller
    {

        public function initialize()
        {
            // Компонент CSRF всегда включен.
            $this->loadComponent('Csrf');
        }

    }
    
В дополнение к методу ``initialize()``, более старое свойство ``$components``
также позволит вам объявлять обязательные к загрузке компоненты. В то время,
как применяются стандартные правила наследования ООП, компоненты и хелперы,
используемые контроллером обрабатываются по-особому. В данном случае значения
свойств класса ``AppController`` объединяются с массивами дочерних классов
контроллеров. Значения дочерних классов всегда переопределяют значения из
``AppController``.

Поток запросов
==============

Когда к приложению CakePHP делается запрос, классы CakePHP
:php:class:`Cake\\Routing\\Router` и :php:class:`Cake\\Routing\\Dispatcher`
используют :ref:`routes-configuration` для обнаружения и создания верного
экземпляра класса контроллера. Данные запроса инкапсулируются в объект запроса.
CakePHP помещает всю важную информацию из запроса в свойство ``$this->request``.
Для более подробной информации об объекте запроса смотрите раздел :ref:`cake-request`.

Экшены контроллера
==================

Экшены контроллера ответственны за преобразование параметров запроса в ответ
для браузера/пользователя совершающего запрос. CakePHP использует соглашения
для автоматизации данного процесса и для устранения некоторого шаблонного кода,
который вам пришлось бы писать в противном случае.

По соглашению, CakePHP обрабатывает вид с именем, соответствующим имени экшена.
Возвращаясь к нашему примеру онлайн пекарни, наш контроллер может содержать
экшены ``view()``, ``share()``, и ``search()``. Контроллер может быть найден в
файле **src/Controller/RecipesController.php** и содержать следующий код::

    // src/Controller/RecipesController.php

    class RecipesController extends AppController
    {
        public function view($id)
        {
            // Здесь описывается вся логика экшена.
        }

        public function share($customerId, $recipeId)
        {
            // Здесь описывается вся логика экшена.
        }

        public function search($query)
        {
            // Здесь описывается вся логика экшена.
        }
    }

Файлы шаблонов для этих экшенов, назывались бы **src/Template/Recipes/view.ctp**,
**src/Template/Recipes/share.ctp**, и **src/Template/Recipes/search.ctp**. По
соглашениям имя файла вида соответствует имени экшена контроллера, записанном в
нижнем регистре с использованием подчеркиваний для разделения слов.

Экшены контроллера обычно используют метод ``Controller::set()`` для создания
контекста, используемого ``View`` для обработки слоя вида. Благодаря соглашениям,
используемым CakePHP, вам не нужно самим создавать и обрабатывать виды. Вместо этого
как только сработает экшен контроллера, CakePHP сам произведет обработку и передачу
Вида.

Если по каким-либо причинам вам захочется изменить стандартное поведение, вы можете
вернуть объект :php:class:`Cake\\Http\\Response` из экшена с полностью созданным
ответом.

Чтобы вы могли эффективно использовать контроллер в своем приложении, мы
охватим некоторые основные атрибуты и методы, предоставляемые контроллерами CakePHP.

Взаимодействие с видами
=======================

Контроллеры взаимодействуют с видами несколькими способами. Во-первых,
они способны передавать данные видам, используя метод ``Controller::set()``.
Вы также можете решить, какой класс вида использовать, какой файл вида должен быть
выведен контроллером.

.. _setting-view_variables:

Назначение переменных вида
--------------------------

.. php:method:: set(string $var, mixed $value)

Метод ``Controller::set()`` - это основной способ передачи данных от вашего контроллера
в ваш вид. Как только вы используете ``Controller::set()``, переменная становится
доступной в вашем виде::

    // Сначала передаете данные от контроллера:

    $this->set('color', 'розовая');

    // После этого, в виде вы можете использовать данные:
    ?>

    Вы выбрали <?= h($color) ?> глазурь для торта.

Метод ``Controller::set()`` также  принимает ассоциативный массив в качестве своего первого
параметра. Это часто может быть быстрым способом назначить набор сведений для
представления::

    $data = [
        'color' => 'pink',
        'type' => 'sugar',
        'base_price' => 23.95
    ];

    // Делаем $color, $type, и $base_price
    // доступными в виде:

    $this->set($data);

Установка параметров вида
-------------------------

Если вы хотите настроить класс вида, пути макета/шаблона, хелперы или тему, которая
должна использоваться при выводе вида, вы можете использовать метод ``viewBuilder()``
для получения билдера. Этот билдер может быть использован для определения свойств
вида перед его созданием::

    $this->viewBuilder()
        ->helpers(['MyCustom'])
        ->theme('Modern')
        ->className('Modern.Admin');

Приведенный выше код показывает, как вы можете загрузить пользовательские
хелперы, установить тему и использовать нестандартный класс вида.

.. versionadded:: 3.1
    ViewBuilder был добавлен в версии 3.1

Обработка вида
--------------

.. php:method:: render(string $view, string $layout)

Метод ``Controller::render()`` автоматически вызывается в конце каждого
запрошенного экшена контроллера. Этот метод выполняет всю логику вида
(используя данные, переданные методом ``Controller::set()``), помещает
вид в его макет ``View::$layout``, и отдает обратно пользователю.

Стандартный  используемый файл вида определяется соглашениями.
Если запрашивается экшен ``search()`` из RecipesController, будет
обработан файл вида **src/Template/Recipes/search.ctp**::

    namespace App\Controller;

    class RecipesController extends AppController
    {
    // ...
        public function search()
        {
            // Обработка вида из src/Template/Recipes/search.ctp
            $this->render();
        }
    // ...
    }

Хотя CakePHP будет автоматически вызывать его после логики каждого экшена
(если вы не задали параметру ``$this->autoRender`` значение ``false``),
вы можете использовать его для указания альтернативного файла вида, указав
имя файла в качестве первого аргумента метода ``Controller::render()``.

Если ``$view`` начинается с '/', предполагается, что путь к этому файлу
вида или элементу задан относительно папки **src/Template**. Это упрощает
обращение к  элементам, к примеру в вызовах AJAX::

    // Обработка элемента из src/Template/Element/ajaxreturn.ctp
    $this->render('/Element/ajaxreturn');

Второй параметр ``$layout`` метода ``Controller::render()`` позволяет вам
определить макет внутри которого вид будет отображаться.


Подробнее о контроллерах
========================

.. toctree::
    :maxdepth: 1

    controllers/pages-controller
    controllers/components


.. meta::
    :title lang=ru: Контроллеры
    :keywords lang=ru: correct models,класс контроллера,controller controller,core library,single model,request data,middle man,bakery,mvc,attributes,логика,recipes
